<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-726:原子的数量</title>
    <link href="/2021/07/05/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2021/07/05/leetcode-726-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目叙述"><a href="#题目叙述" class="headerlink" title="# 题目叙述"></a># 题目叙述</h3><p>给定一个化学式<code>formula</code>（作为字符串），返回每种原子的数量。</p><p>原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。</p><p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。</p><p>两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。</p><p>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。</p><p>给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p><p>示例 1:</p><p>输入: </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">formula</span> = <span class="hljs-string">&quot;H2O&quot;</span><br>输出: <span class="hljs-string">&quot;H2O&quot;</span><br>解释: <br>原子的数量是 &#123;<span class="hljs-string">&#x27;H&#x27;</span>: 2, <span class="hljs-string">&#x27;O&#x27;</span>: 1&#125;。<br></code></pre></td></tr></table></figure><p>示例 2:</p><p>输入: </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">formula</span> = <span class="hljs-string">&quot;Mg(OH)2&quot;</span><br>输出: <span class="hljs-string">&quot;H2MgO2&quot;</span><br>解释: <br>原子的数量是 &#123;<span class="hljs-string">&#x27;H&#x27;</span>: 2, <span class="hljs-string">&#x27;Mg&#x27;</span>: 1, <span class="hljs-string">&#x27;O&#x27;</span>: 2&#125;。<br></code></pre></td></tr></table></figure><p>示例 3:</p><p>输入: </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">formula</span> = <span class="hljs-string">&quot;K4(ON(SO3)2)2&quot;</span><br>输出: <span class="hljs-string">&quot;K4N2O14S4&quot;</span><br>解释: <br>原子的数量是 &#123;<span class="hljs-string">&#x27;K&#x27;</span>: 4, <span class="hljs-string">&#x27;N&#x27;</span>: 2, <span class="hljs-string">&#x27;O&#x27;</span>: 14, <span class="hljs-string">&#x27;S&#x27;</span>: 4&#125;。<br></code></pre></td></tr></table></figure><h3 id="尝试思路"><a href="#尝试思路" class="headerlink" title="# 尝试思路"></a># 尝试思路</h3><p>一般看见这种嵌套括号的题目基本都是栈，这个很好理解，(()) 如这两层结构肯定得先算最里面的一层。</p><p>题目要求按照字典序列排序，并且要统计每个原子和对应数量，首选肯定是<code>Map&lt;String, Integer&gt;</code>，先把所有原子装进去再进行输出处理。输出字典序就用<code>TreeMap</code>，内部有链表维护顺序，emmm看起来选的好像挺完美的。</p><p>看看示例3，发现原理好像很简单，数据结构也选好了，算法怎么算也想好了，怎么写呢？好像实现起来有很多细节。直接贴上代码，没什么好讲的。一分钟出思路，一小时出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LC726</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 这里设为类成员的原因是，很多方法要共用这些东西并且需要修改。所以不能用参数的形式。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> n;<br>    String formula;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countOfAtoms</span><span class="hljs-params">(String formula)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = formula.length();<br>        <span class="hljs-keyword">this</span>.i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.formula = formula;<br><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br><br>        <span class="hljs-comment">// 这里的用法比较讲究 (官方题解的思路)</span><br>        Deque&lt;Map&lt;String, Integer&gt;&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br><br>        <span class="hljs-keyword">while</span>(i &lt; n) &#123;<br>            <span class="hljs-keyword">char</span> c = formula.charAt(i);<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                i ++;<br>                stack.push(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                i ++;<br>                <span class="hljs-keyword">int</span> num = parseNum();<br>                Map&lt;String, Integer&gt; popMap = stack.pop();<br>                Map&lt;String, Integer&gt; peekMap = stack.peek();<br>                <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : popMap.entrySet()) &#123;<br>                    String atom = entry.getKey();<br>                    <span class="hljs-keyword">int</span> v = entry.getValue();<br>                    peekMap.put(atom, peekMap.getOrDefault(atom, <span class="hljs-number">0</span>) + v * num);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                String atom = parseAtom();<br>                <span class="hljs-keyword">int</span> num = parseNum();<br>                Map&lt;String, Integer&gt; peekMap = stack.peek();<br>                peekMap.put(atom, peekMap.getOrDefault(atom, <span class="hljs-number">0</span>) + num);<br>            &#125;<br>        &#125;<br><br>        Map&lt;String, Integer&gt; map = stack.pop();<br>        TreeMap&lt;String, Integer&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(map);<br><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : treeMap.entrySet()) &#123;<br>            String atom = entry.getKey();<br>            <span class="hljs-keyword">int</span> count = entry.getValue();<br>            result.append(atom);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">1</span>) &#123;<br>                result.append(count);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 取出每个原子</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">parseAtom</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        stringBuilder.append(formula.charAt(i ++));<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; Character.isLowerCase(formula.charAt(i))) &#123;<br>            stringBuilder.append(formula.charAt(i ++));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 解析原子后面的数字</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n || !Character.isDigit(formula.charAt(i))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; Character.isDigit(formula.charAt(i))) &#123;<br>            num = num * <span class="hljs-number">10</span> + formula.charAt(i++) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-645错误的集合</title>
    <link href="/2021/07/04/leetcode-645%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <url>/2021/07/04/leetcode-645%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目叙述"><a href="#题目叙述" class="headerlink" title="# 题目叙述"></a># 题目叙述</h3><p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 有一个数字重复 。</p><p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p><p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2,4]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><h3 id="尝试思路"><a href="#尝试思路" class="headerlink" title="# 尝试思路"></a># 尝试思路</h3><p>这种一般直接用Map统计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findErrorNums(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 结果集</span><br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 如果包含，取value；若不包含，取0. 【下附getOrDefault()的源码】</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)  &#123;<br>        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 直接处理结果就可以了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        <span class="hljs-keyword">int</span> count = map.getOrDefault(i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">2</span>) &#123;<br>            result[<span class="hljs-number">0</span>] = i;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;<br>            result[<span class="hljs-number">1</span>] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getOrDefault()</code>方法源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">getOrDefault</span><span class="hljs-params">(Object key, V defaultValue)</span> </span>&#123;<br>    V v;<br>    <span class="hljs-keyword">return</span> (((v = get(key)) != <span class="hljs-keyword">null</span>) || containsKey(key))<br>        ? v<br>        : defaultValue;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-451:根据字符出现频率排序</title>
    <link href="/2021/07/03/leetcode-451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/03/leetcode-451%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目叙述"><a href="#题目叙述" class="headerlink" title="# 题目叙述"></a># 题目叙述</h3><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p>示例 1:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入:<br><span class="hljs-string">&quot;tree&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;eert&quot;</span><br><br>解释:<br>&#x27;e&#x27;出现两次，&#x27;r&#x27;和&#x27;t&#x27;都只出现一次。<br>因此&#x27;e&#x27;必须出现在&#x27;r&#x27;和&#x27;t&#x27;之前。此外，<span class="hljs-string">&quot;eetr&quot;</span>也是一个有效的答案。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br><span class="hljs-string">&quot;cccaaa&quot;</span><br><br><span class="hljs-section">输出:</span><br><span class="hljs-string">&quot;cccaaa&quot;</span><br><br><span class="hljs-section">解释:</span><br>&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，<span class="hljs-string">&quot;aaaccc&quot;</span>也是有效的答案。<br>注意<span class="hljs-string">&quot;cacaca&quot;</span>是不正确的，因为相同的字母必须放在一起。<br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br><span class="hljs-string">&quot;Aabb&quot;</span><br><br><span class="hljs-section">输出:</span><br><span class="hljs-string">&quot;bbAa&quot;</span><br><br><span class="hljs-section">解释:</span><br>此外，<span class="hljs-string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="hljs-string">&quot;Aabb&quot;</span>是不正确的。<br>注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。<br></code></pre></td></tr></table></figure><h3 id="尝试思路"><a href="#尝试思路" class="headerlink" title="# 尝试思路"></a># 尝试思路</h3><p>乍一看题，直接二维hash，数组长度为52【大写26个 + 小写26个】 + 冒泡，输出就ok了。</p><p>然而 … </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">8</span> / <span class="hljs-number">32</span> 个通过测试用例<br>状态：执行出错<br>提交时间：<span class="hljs-number">1</span> 小时前<br>执行出错信息：<br>java.lang.ArrayIndexOutOfBoundsException: Index <span class="hljs-number">-15</span> out <span class="hljs-keyword">of</span> bounds <span class="hljs-keyword">for</span> <span class="hljs-built_in">length</span> <span class="hljs-number">52</span><br>  <span class="hljs-keyword">at</span> <span class="hljs-built_in">line</span> <span class="hljs-number">11</span>, Solution.frequencySort<br>  <span class="hljs-keyword">at</span> <span class="hljs-built_in">line</span> <span class="hljs-number">54</span>, __DriverSolution__.__helper__<br>  <span class="hljs-keyword">at</span> <span class="hljs-built_in">line</span> <span class="hljs-number">84</span>, __Driver__.main<br>最后执行的输入：<br><span class="hljs-string">&quot;2a554442f544asfasssffffasss&quot;</span><br></code></pre></td></tr></table></figure><p>哦~ 原来是有数字的啊。 将二维hash数组换为HashMap， 这时候就体现了数组干不了的事情了(或者说这就是Map的强大之处)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 定义哈希字典</span><br>    Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 遍历，并更新K-V</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(dic.containsKey(c)) &#123;<br>            temp = dic.get(c);<br>            temp ++;<br>        &#125;<br>        dic.put(c, temp);<br>    &#125;<br><br>    <span class="hljs-comment">// 转换list排序</span><br>    List&lt;Map.Entry&lt;Character, Integer&gt;&gt; dicList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(dic.entrySet());<br><br>    <span class="hljs-comment">// list排序，添加Comparator比较器，匿名Lambda</span><br>    dicList.sort((o1, o2) -&gt; (o2.getValue() - o1.getValue()));<br><br>    <span class="hljs-comment">// 输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; dicList.size();i ++) &#123;<br>        <span class="hljs-keyword">if</span>(dicList.get(i).getValue() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> times = dicList.get(i).getValue(); times &gt; <span class="hljs-number">0</span>; times --) &#123;<br>                result.append(dicList.get(i).getKey());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我可爱的小博客</title>
    <link href="/2021/07/01/%E6%88%91%E5%8F%AF%E7%88%B1%E7%9A%84%E5%B0%8F%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/01/%E6%88%91%E5%8F%AF%E7%88%B1%E7%9A%84%E5%B0%8F%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我可爱的小博客"><a href="#我可爱的小博客" class="headerlink" title="我可爱的小博客"></a>我可爱的小博客</h1><p>之前用Typora + Server搭过一篇，发现并不是很好用。</p><p>其实现在也挺狗血的，但毕竟有自己的东西，勉强接受吧…</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://lucifer-rossweisse.github.io/2021/01/12/github+hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/">参考教程</a></p><p>之后将hexo 和 github绑定起来就可以了。</p><p>选一个自己喜欢的主题，Github搜一下Hexo theme有一大堆，不过也没自己喜欢的那个 …</p><h4 id="废话终于说完了"><a href="#废话终于说完了" class="headerlink" title="废话终于说完了"></a>废话终于说完了</h4><p>最后感谢自己的支持！</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
